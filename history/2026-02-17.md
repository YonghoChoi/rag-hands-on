# 2026-02-17 세션 기록

## 사용자 요청 1
git pull로 최신화하고 전체 내용 숙지

### AI 응답
- git pull 실행 완료 (Already up to date)
- history 디렉토리 확인 완료 (비어있음)
- 프로젝트 구조 파악:
  - Amazon Bedrock Knowledge Bases RAG 예제 프로젝트
  - 01-rag-concepts: 기본 RAG 개념 및 KB 생성
  - 02-optimizing-accuracy-retrieved-results: 청킹 전략 최적화
  - 03-responsible-ai: 책임 있는 AI
  - 04-multi-modal-rag: 멀티모달 RAG
  - 05-structured-rag: 구조화된 RAG
  - 06-graph-rag: 그래프 RAG
  - utils: 헬퍼 클래스들

## 사용자 요청 2
04_advanced_chunking_options.ipynb 파일 내용을 참고해서 06번 파일을 생성합니다. 
기존 파일에는 BedrockKnowledgeBase를 새로 생성하고 있습니다. 
06번 파일에서는 kb_id를 활용해서 기존의 BedrockKnowledgeBase는 그대로 유지하고, Data Source만 추가하도록 코드를 작성합니다.

### AI 작업 진행 중
- advanced_chunking_options.ipynb 파일 분석 완료
- 기존 파일은 BedrockKnowledgeBase 클래스로 새 KB를 생성
- 요청사항: 기존 KB ID를 사용하여 Data Source만 추가하는 노트북 생성


### AI 작업 완료
06번 파일 생성 완료: `01-rag-concepts/06_add_data_source_to_existing_kb.ipynb`

#### 생성된 파일의 주요 특징:
1. 기존 KB ID를 입력받아 사용
2. BedrockKnowledgeBase 클래스의 `create_data_sources` 메서드 활용
3. 새로운 S3 버킷 생성 및 데이터 업로드
4. 기존 KB 실행 역할에 새 버킷 권한 추가
5. Data Source만 추가 (KB는 재생성하지 않음)
6. Ingestion 작업 자동 실행 및 상태 모니터링
7. 테스트 및 검증 코드 포함

#### 주요 차이점 (04번 파일과 비교):
- 04번: BedrockKnowledgeBase 전체를 새로 생성
- 06번: 기존 KB ID를 사용하여 Data Source만 추가
- IAM 권한 추가 로직 포함
- 모든 Data Source 목록 조회 기능 추가


## 사용자 요청 3
코드가 너무 복잡합니다. BedrockKnowledgeBase 인스턴스를 생성하면 새로운 KB가 생성됩니다. 
S3 bucket도 새로 생성하지 말고 미리 생성해놓은 버킷을 그대로 이용하도록 해주세요.

### AI 작업 완료
06번 파일을 대폭 간소화:

#### 주요 변경사항:
1. BedrockKnowledgeBase 클래스 사용 제거 → boto3 클라이언트 직접 사용
2. S3 버킷 생성 로직 제거 → 기존 버킷 이름만 입력받도록 변경
3. IAM 권한 추가 로직 제거 → 사전 준비 사항으로 안내
4. 불필요한 import 제거 (os, sys, logging, json, Path 등)
5. 코드 복잡도 대폭 감소

#### 최종 워크플로우:
1. 기존 KB ID와 S3 버킷 이름 입력
2. boto3로 Data Source 직접 생성
3. Ingestion 작업 시작
4. 테스트

훨씬 간단하고 직관적인 코드로 개선되었습니다.


## 사용자 질문 4
동일한 bedrock knowledge base에 대해서 여러 datasource를 만들고 vector database의 index를 각 datasource마다 다르게 설정할 수 있습니까?

### AI 답변
**아니요, 불가능합니다.**

#### Amazon Bedrock Knowledge Base 아키텍처:
- 하나의 Knowledge Base = 하나의 벡터 인덱스
- 여러 Data Source는 동일한 벡터 인덱스를 공유
- 모든 Data Source는 동일한 임베딩 모델과 청킹 전략 사용

#### 구조:
```
Knowledge Base
├── Vector Store (OpenSearch Serverless Collection)
│   └── Vector Index (하나만)
│       ├── Data Source 1의 벡터들
│       ├── Data Source 2의 벡터들
│       └── Data Source 3의 벡터들
```

#### 다른 인덱스가 필요한 경우:
- 별도의 Knowledge Base를 생성해야 함
- 각 KB는 독립적인 벡터 인덱스를 가짐

#### 대안 - 메타데이터 필터링:
- 동일한 인덱스 내에서 Data Source별 검색 가능
- `x-amz-bedrock-kb-data-source-id` 메타데이터 사용
- retrievalConfiguration의 filter 옵션 활용


## 사용자 요청 5
여러 KB를 만들더라도 동일한 Vector Database를 사용하고 index만 다르게 설정하도록 코드를 구현해주세요. 
Vector database는 최초 KB를 만들 때 한번만 생성하고 이후 KB를 생성할 때는 이미 생성된 OpenSearch Serverless를 사용하도록 해주세요.

### AI 작업 완료
07번 파일 생성: `01-rag-concepts/07_multiple_kb_shared_vector_db.ipynb`

#### 구현 내용:
1. **첫 번째 KB 생성 시 OSS Collection 생성**
   - BedrockKnowledgeBase 클래스로 KB 생성
   - OpenSearch Serverless Collection 자동 생성
   - Collection ID, ARN, Host 정보 저장

2. **추가 KB 생성 시 기존 OSS Collection 재사용**
   - BedrockKnowledgeBase 클래스는 이미 존재하는 Collection 감지
   - 새로운 Collection 생성하지 않고 재사용
   - 각 KB마다 독립적인 벡터 인덱스 생성

3. **3개의 KB 생성 예제**
   - KB 1: Fixed Size Chunking
   - KB 2: Hierarchical Chunking
   - KB 3: Semantic Chunking

4. **테스트 및 검증**
   - 각 KB에 동일한 질의로 테스트
   - OSS Collection의 모든 인덱스 조회
   - 청킹 전략별 결과 비교

#### 장점:
- OSS Collection 비용 절감 (하나만 생성)
- 각 KB는 독립적으로 관리 가능
- 서로 다른 청킹 전략 적용 가능


## 세션 재시작 (컨텍스트 전환)
이전 세션에서 07번 파일에 JSON 구문 오류가 있었음 (cells 배열이 제대로 닫히지 않음)

### AI 작업 완료
JSON 구문 오류 수정:
- 파일을 처음부터 다시 생성하여 올바른 JSON 구조로 재작성
- cells 배열이 올바르게 닫히도록 수정
- 노트북이 정상적으로 열리는 것 확인

07번 파일 (`01-rag-concepts/07_multiple_kb_shared_vector_db.ipynb`) 정상 작동 확인 완료.


## 사용자 질문 6
커널 재시작 코드의 의미와 왜 HTML/JavaScript를 사용하는지?

### AI 답변
**코드 의미:**
```python
from IPython.core.display import HTML
HTML("<script>Jupyter.notebook.kernel.restart()</script>")
```
- Jupyter 노트북의 Python 커널을 재시작하는 코드
- 패키지 설치 후 새로 설치된 패키지를 인식하도록 하기 위해 사용

**왜 HTML/JavaScript를 사용하는가:**

1. **아키텍처 제약**: 
   - Jupyter는 Frontend(브라우저) + Backend(Python 커널) 구조
   - 커널은 자기 자신을 재시작할 수 없음 (논리적 모순)
   
2. **실행 흐름**:
   - Python 코드 → HTML/JavaScript 생성 → 브라우저 실행 → Jupyter Server에 재시작 요청 → 커널 재시작
   
3. **커널 재시작은 Frontend의 역할**:
   - `Jupyter.notebook.kernel.restart()`는 JavaScript API
   - Jupyter Server가 커널 프로세스를 관리
   - Python에서 직접 재시작 불가능

**사용 시나리오:**
- `%pip install` 후 새 패키지를 즉시 사용해야 할 때
- 커널 재시작 후 모든 변수/import 초기화됨


## 사용자 요청 7
현재까지 변경된 내용을 기반으로 git add, commit, push 해주세요

### AI 작업 완료
Git 작업 완료:

1. **git status 확인**:
   - 새로 추가된 파일들 확인
   - 06_add_data_source_to_existing_kb.ipynb
   - 07_multiple_kb_shared_vector_db.ipynb
   - history/ 디렉토리

2. **git add**:
   - 모든 변경된 파일 스테이징

3. **git commit**:
   - 커밋 메시지: "Add new notebooks: 06_add_data_source_to_existing_kb and 07_multiple_kb_shared_vector_db"
   - 4개 파일, 1064줄 추가

4. **git push**:
   - origin/main에 성공적으로 푸시 완료
   - 커밋 해시: 961b975


## 사용자 요청 8
boto3 라이브러리를 사용해서 직접 KB를 생성하는 코드 작성. Data Source는 S3 버킷을 직접 지정, Vector Database는 이미 존재하는 OpenSearch Serverless Collection 사용, 원하는 index 지정. 08번 파일로 생성.

### AI 작업 완료
08번 파일 생성: `01-rag-concepts/08_create_kb_with_existing_oss.ipynb`

#### 구현 내용:
1. **BedrockKnowledgeBase 클래스 사용하지 않음**
   - boto3 클라이언트 직접 사용
   - 모든 설정을 수동으로 제어

2. **IAM 역할 생성**
   - S3 접근 권한 (GetObject, ListBucket)
   - OpenSearch Serverless 접근 권한 (APIAccessAll)
   - Bedrock 모델 호출 권한 (InvokeModel)
   - Trust Policy로 Bedrock 서비스가 역할 assume 가능하도록 설정

3. **Knowledge Base 생성**
   - 기존 OSS Collection ARN 지정
   - 원하는 인덱스 이름 직접 지정
   - 임베딩 모델 ARN 설정
   - fieldMapping 설정 (vectorField, textField, metadataField)

4. **Data Source 추가**
   - 기존 S3 버킷 ARN 지정
   - 청킹 전략 설정 (FIXED_SIZE)

5. **Ingestion 및 테스트**
   - Ingestion 작업 시작 및 모니터링
   - OpenSearch 클라이언트로 인덱스 확인
   - retrieve_and_generate로 테스트

#### BedrockKnowledgeBase 클래스와의 차이:
- BedrockKnowledgeBase: 자동으로 리소스 생성/관리 (제어 제한적)
- boto3 직접 사용: 모든 설정을 직접 제어 (Collection, 인덱스, IAM 등)

#### 장점:
- 기존 OSS Collection 재사용
- 원하는 인덱스 이름 직접 지정
- 세밀한 IAM 권한 제어
- 여러 KB가 동일한 Collection 공유하면서 독립적인 인덱스 사용


## 사용자 요청 9
현재까지 변경되거나 추가된 내용을 commit 메시지로 작성하여 git add, git commit, git push 수행

### AI 작업 완료
Git 작업 완료:

1. **git status 확인**:
   - 수정된 파일: 07_multiple_kb_shared_vector_db.ipynb, history/2026-02-17.md
   - 새로 추가된 파일: 00_create_bedrock_kb.ipynb, 08_create_kb_with_existing_oss.ipynb
   - 이미지 파일: rag_1.png, rag_2.png, rag_3.png

2. **git add**:
   - 모든 변경 및 추가된 파일 스테이징

3. **git commit**:
   - 커밋 메시지: "Add notebook for creating KB with existing OSS Collection using boto3"
   - 6개 파일, 1792줄 추가
   - 커밋 해시: b259ce9

4. **git push**:
   - origin/main에 성공적으로 푸시 완료
   - 11개 객체 전송 (606.32 KiB)
